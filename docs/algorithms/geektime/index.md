

## 学习方法

- [ ] 集中把本周的内容涉及的数据结构和算法，全都自己写出来，用代码实现一遍。
- [ ] 完成课后思考
- [ ] 提出问题：能解决的解决，不能解决的记录

---

## 资料
[不同数据类型的不同语言实现](https://github.com/wangzheng0822)

---
> 入门篇


## 学习方法（01、02节）
数据结构和算法这个东西，如果你不去学，可能真的这辈子都用不到，也感受不到它的好。但是一旦掌握，你就会常常被它的强大威力所折服。之前你可能需要费很大劲儿来优化的代码，需要花很多心思来设计的架构，用了数据结构和算法之后，很容易就可以解决了。
学习要学会找重点。如果不分重点地学习，眉毛胡子一把抓，学起来肯定会比较吃力。
要学习它的“来历”“自身的特点”“适合解决的问题”以及“实际的应用场景”。
集中把这周的三节内容涉及的数据结构和算法，全都自己写出来，用代码实现一遍。
如果是应对国内公司的技术面试，即便是 BAT 这样的公司，你只要彻底掌握这个专栏的内容，就足以应对。
学习知识的过程是反复迭代、不断沉淀的过程。


## 02 
从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。
复杂度分析：熟练
10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；
10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。

**思考：你自己的学习方法**
在上面的学习方法段落

-------
### 时间/空间复杂度
事后统计法：依赖测试环境、受数据规模的影响
大 O 复杂度表示法可以是我们刨除所有其他的外来变量影响，只对代码进行粗略的评估。
大 O 复杂度表示法只考虑每行代码的执行的消耗时间T(n)与代码执行次数f(n)的关系。
大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示**代码执行时间随数据规模增长的变化趋势**，公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。

```
T(n) = O(f(n))
T(n) = O(2n^2 + 2n + 3)
T(n) = O(n^2)
```

1. 只关注循环执行次数最多的一段代码
2. 加法法则：总复杂度等于量级最大的那段代码的复杂度
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

O(1)常量级时间复杂度
O(logn)、O(nlogn)对数级时间复杂度
O(m+n)、O(m*n)由数据规模决定
O(n2)、O(n3)
`![坐标系](./assets/坐标系.webp)`

空间复杂度：存储空间与数据规模之间的增长关系。

**思考：有人说，我们项目之前都会进行性能测试，再做代码的时间复杂度、空间复杂度分析，是不是多此一举呢？而且，每段代码都分析一下时间复杂度、空间复杂度，是不是很浪费时间呢？你怎么看待这个问题呢？**
性能测试提供真实的执行时间，帮助我们缩小可能出现性能瓶颈的位置，而时间、空间复杂度分析提供理论上的支持，是我们努力的方向。
开发时"浪费"的时间与空间，最终都会在实际运行时为我们节省时间与空间成本。

### 最好、最坏、平均、平摊时间复杂度
最好时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。
最坏时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。
- [ ] 平均时间复杂度
均摊时间复杂度：把耗时多的那次操作均摊到耗时少的操作上
只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。

#### 思考：
[add函数的时间复杂度](https://time.geekbang.org/column/article/40447)
平时是O(1)，特殊是O(n)。所以最好是O(1)，最坏是(n)，均摊是O(1)


-------
> 基础篇


## 数组
数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。
![线性表](https://static001.geekbang.org/resource/image/b6/77/b6b71ec46935130dff5c4b62cf273477.jpg)

当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址。
数组的访问越界问题

数组的插入、删除也有相对来说简单的操作，把新插入的元素放到k位置，原来第k个位置的数放到位置n。删除也是，删除某个元素，该位置就空着（用一个特殊的值去记录以保证数据的连续性）。时间复杂度会降低为O(1)。
还有种方法是多次删除仅为标记，异步执行真正的删除操作。

线性表：只有前后两个方向
为什么数组从零开始编号，下标是数组首地址的偏移，从0开始更方便。


#### 应用
**为什么很多编程语言中数组都从0开始编号？**
通过数组下标访问数组内的某个元素，其实是计算数组及下标偏移量，如果以1开始下标那么每次访问`arr[i]`时需要根据 `arr` 的内存地址加上 `i - 1` 个偏移量。更可能的原因是以后的编程语言只是模仿C语言，减少学习成本。

**JVM 标记清除垃圾回收算法的核心思想**

**Java语言中，什么时候用数组，什么时候用容器**

#### 问题
- [ ] 在 JavaScript 这种类似的弱类型语言中，数组内的值可以是任意类型，JS如何为数组分配内存空间。

#### 思考
- [ ] 1、前面我基于数组的原理引出 JVM 的标记清除垃圾回收算法的核心理念。我不知道你是否使用 Java 语言，理解 JVM，如果你熟悉，可以在评论区回顾下你理解的标记清除垃圾回收算法。
2、前面我们讲到一维数组的内存寻址公式，那你可以思考一下，类比一下，二维数组的内存寻址公式是怎样的呢？
```
// 一维数组
a[k]_address = base_address + k * type_size

// 二维数组(假设每个一维数组的长度相同，且为n)
a[j][k]_address = base_address + ( n * j + k) * type_size
```

## 链表
数组：
- 需要连续空间、对内存要求比较高。
- 扩容麻烦，需要 O(n) 的时间复杂度计算。
- 占用内存更小。

链表：
- 内存要求低，但是容易形成内存碎片。
- 天然支持动态扩容。
- 占用内存更大。

单链表：第一个节点叫头节点，记录链表基地址，最后一个节点叫尾节点，指向空地址NULL。
双向链表：使得能够获取到当前节点的前一个节点的时间复杂度为O(1)，应用更广泛。
循环链表：尾指向头

空间换时间的设计思想。
在实际的软件开发中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。

#### 应用
**谍战片里的不同接头人之间的关系最好使用单向链表这种数据结构**
组织级别最高的人为链表的头，组织级别最低的人为链表的尾。可以即使策反了级别低的人，也很难向上查找找到更高级别的人。这里只考虑的每个节点只有一人，如果一个人对应多个人，那么就是单向树（如果有）这种数据结构。

**如何用链表来实现 LRU 缓存淘汰策略呢？**

  - [ ] **[约瑟夫问题](https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98)** 使用双向链表

技巧：
- 理解指针和引用的含义：实际操作用用到的，不能直接将 `linkList.next` 赋值给 `temp`，应该只在`temp`上操作
- 警惕指针丢失和内存泄漏
- 利用哨兵简化实现难度
- 重点留意边界条件处理
  - 如果链表为空时，代码是否能正常工作？
  - 如果链表只包含一个结点时，代码是否能正常工作？
  - 如果链表只包含两个结点时，代码是否能正常工作？
  - 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？
- 举例画图，辅助思考
- 多写多练，没有捷径

#### 问题
#### 思考
- [ ] **请分别使用链表、数组实现 LRU 缓存淘汰策略。**

- [ ] **如何判断一个字符串是否是回文字符串的问题，**

- [ ] **如果字符串是通过单链表来存储的，那该如何来判断是一个回文串呢？你有什么好的解决思路呢？相应的时间空间复杂度又是多少呢？**
- [ ] **将反转列表功能加入到代码中**
- [ ] 链表中环的检测
- [ ] 两个有序的链表合并
- [ ] 删除链表倒数第 n 个结点
- [ ] 求链表的中间结点

## 栈
先进后出
用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。
栈是一种操作受限的数据结构，只支持入栈和出栈操作。后进先出是它最大的特点。栈既可以通过数组实现，也可以通过链表来实现。不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)。除此之外，我们还讲了一种支持动态扩容的顺序栈，你需要重点掌握它的均摊时间复杂度分析方法。

#### 应用
盘子
函数调用栈
算术表达式
检查字符串中括号否合法
浏览器的前进后退


#### 问题
- [ ] 我们在讲栈的应用时，讲到用函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？
#### 思考


## xxx
#### 应用
#### 问题
#### 思考







