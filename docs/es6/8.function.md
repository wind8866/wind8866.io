[toc]

---

## 概览
### 函数的特性
函数可重复声明，后面的会覆盖前面的声明
函数声明会提前到代码块最上面
函数内的作用域
函数执行时的作用域为声明时所在作用域，与当前运行的作用域无关。
函数内的this为当前执行环境的this，与定义环境无关。
函数参数是按值传递，复合类型的值是引用地址。
函数内部有arguments对象，arguments.length返回参数个数，arguments.callee返回原函数

### 函数的创建方式
```javascript
// 函数声明
function fun() {

}

// 函数表达式
const fun = function () {

}

// 构造函数
const fun = new Function('x', 'y', 'return x + y');

// 箭头函数

const fun = () => {
    
}

```

### 立即调用的函数表达式IIFE
```javascript
(function (){
    // ...
})();
```
作用
- 不必为函数命名，避免了污染全局变量
- IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。

### 理解闭包
#### 闭包是如何实现的
函数内的作用域是局部的，函数外不能访问内部的变量
函数的作用域为函数声明时的作用域
那么如果在函数wrap内部声明的函数inner，inner函数的作用域链中就包括wrap的作用域，如果把它返回到global，那么global就可以访问inner内的变量。

```javascript
function wrap() {
    let a = 12;
    function inner() {
        return a;
    }
    return inner;
}
const a = 11;
const wrapInner = wrap();
console.log(wrapInner());
// 12
```

#### 闭包的作用
- 可以读取函数内部的变量
- 让这些变量始终保持在内存中
- 封装对象的私有属性和私有方法

### eval
eval接受字符串，将其当作语句执行。
eval没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。
不建议使用

## ES6有哪些改进
- 参数可以设置默认值
    - 根据是否等于undefined判断是否使用默认值
    - 设置默认值后不被计入预期参数个数
    - 参数的设置默认值也会形成作用域
- rest参数
    - 定义时只能放在最后一个参数
- 严格模式
    - 规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。
- 箭头函数
    - 简化了函数
    - this指向定义时所在环境，箭头函数没有自己的this
    - 不可使用arguments
    - 不可使用yield
    - 不适用于对象的方法中，所以vue中使用箭头函数会找不到this，因为指向了全局
    - 动态this时也不适用箭头函数，总之
        - 如果不涉及this，用箭头函数
        - 如果使用this，且明确目标this指向定义环境，那么使用箭头函数
        - 否则使用普通函数定义
- 尾调用优化
    - 指某个函数的最后一步是调用另一个函数
    - 能够符合尾调用优化的条件是最后一步执行不需要当前函数作用域内的其他变量
    - 尾递归优化
- 参数最后可有一个逗号
- Function.prototype.toString()不再省略空格和注释
- catch 命令的参数可省略

## 问题

## 待阅读
- 再看一遍有关尾调用优化的内容

## 问题解答

## API
| 方法(6⃣️ === ES6) | 描述 | 分类 |
| --- | --- | --- |
| name | 函数名,可用在传递的参数是函数时用到 | 实例属性 |
| length | 预期参数个数，可用在方法重载 | |
| constructor | 返回原型构造方法 |  |
| toString() | 返回函数源码 | 实例方法 |
| bind() | 改变this，不执行只返回一个新函数 |  |
| call() | 改变this，从第二个参数开始为传递给函数的参数 |  |
| apply() | 与call类似，第二个参数为数组 |  |


