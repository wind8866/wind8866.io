# TypeScript

## 问题
- [x] 什么是类型兼容？
- [x] 异构是什么概念？(可以理解过多种模式混用)
- [x] C、C++是强类型还是弱类型？（两者都属于弱类型静态语言，[参考](https://www.zhihu.com/question/19918532)）
- [x] void与never类型的区别。（[TypeScript中的never类型具体有什么用？](https://www.zhihu.com/question/354601204)）
- [x] 构造函数设置private后还能干什么？意义何在？（那只能使用静态类型了，例如Math不可以new，也不可以继承）
- [x] 抽象类与接口的关系
- [x] 再次学习ES6的《Module 的加载实现》（等到JS学习计划再看）
- [ ] 如何将一个文件默认一个命名空间，否则不同文件间存在命名冲突或者默认的声明合并。
- [ ] 感觉抽象类的作用不大，我们可以使用接口来约束
- [ ] ts 函数兼容 参数多兼容少，为什么这么设计？(可以转化为为什么函数在实现定义接口时参数为什么不能多余定义的参数个数)
- [ ] 再次看高级类型，实现高级类型的代码与笔记
- [ ] babel工程配置成web服务
- [ ] 配置好代码检查工具
- [ ] 单元测试的章节
- [ ] 构建思维导图
- [ ] 做完课后的题目
- [ ] 使用class怎么给类的原型添加方法?

---
---
## 基础篇
### 强类型与弱类型
**强类型语言**
在强类型语言中，当一个对象从调用函数传递到被调用函数时其类型必须与被调用函数中声明的类型兼容。

不允许改变变量的数据类型。

**弱类型语言**
变量可以被赋予不同的数据类型。

### 动态类型语言与静态类型语言
静态：编译阶段确定所有变量的类型，存储偏移量
动态：执行阶段确定所有变量的类型，存储偏移量与属性名

- 静态强类型：Java、C#、TypeScript
- 静态弱类型：
- 动态强类型：Python
- 动态弱类型：PHP、JavaScript

### 环境配置
注意依赖的版本

### 基本类型
- void
- any
- never
- Tuple 元组
- Enum 枚举
- 高阶类型

类型注解相当于JAVA中的类型声明

### 枚举类型
- 数字类型的枚举实现原理：反向映射
- 枚举会被编译为对象
- 枚举的值不可修改
- 枚举的类型（不相同枚举类型不能比较）
  - const: 编译时计算出结果，以常量形式出现在运行时
  - computed: 运行时计算，以表达式出现在运行时
- 常量枚举: 会在编译阶段被移除、不需要变量而只是需要变量的值


### 接口
可以用来约束对象、函数以及类的结构和类型
接口默认遵循鸭子类型原则：实现只需要兼容（满足定义的必要条件）定义的接口即可。
但是上述的情况如果传入对象字面量，会对每个字段进行检查，解决方法有三种。
- 类型断言
- 把对象字面量赋值给一个变量，变量作为接口的实现
- 字符串索引签名：`[x: string]: any`

可选属性：`age?: number`
只读属性：`readonly id: number`

**可索引类型的接口**
可以用来定义不确定属性个数的接口。

**函数类型接口**

### 类
**类的修饰符**
public(公共):
- 类的所有属性默认都是
- 构造函数的参数：作用是将参数变成了实例的属性

private(私有):
- 类的私有成员只能在类的内部调用，不能被类的实例、类的子类调用
- 构造函数：这个类既不能被实例化也不能被继承。

protected(受保护成员):
- 一个受保护成员只能在类或子类中访问，不能在类的实例中访问
- 构造函数：不能被实例化，只能被继承，相当于声明了一个基类

readonly(只读):
- 必须要初始化

static(静态成员):
- 只能通过类名访问，不能通过实例访问

**抽象类**
只能被继承而不能被实例化的类。
抽象类是一种特殊的类，用来约束类。

### 类与接口的关系
一个接口可以约束类成员有哪些属性，以及他们的类型。
类实现接口的时候必须实现接口中声明的所有属性。
接口只能约束类的共有成员，不能约束构造函数。
接口可以继承，并且一个接口可以继承多个接口。
接口可以继承类，把类的成员都抽象出来，只有类的结构，没有具体实现。

接口和类的区别：
- 接口可以继承多个接口，类只能继承一个类
- 类是对象(实例)的抽象，接口是类的抽象
- 接口可以直接实例化（这里不应该叫实例化，或者说可以直接以接口的模版创建对象），类必须使用 new 操作符。

### 泛型
函数输入类型与返回类型的关系约束。
泛型：不预先确定的数据类型，具体的类型在使用的时候才能确定。

不能应用于类的静态成员。
使用泛型可以使类或函数轻松的支持多种类型，增强程序的扩展性。
不必写多条重载，冗长的联合类型声明，增强代码可读性
灵活控制类型之间的约束


### 类型推断
有时不需要主动提供数据的类型,TS会根据相应的规则自动的为其推断出一个类型。
- 基础类型推断：从右到左
- 最佳通用类型推断：最小化的兼容类型
- 上下文类型推断：从左到右

TS推断不出的类型可以使用类型断言。

### 类型兼容
当一个类型Y可以被赋值给另一个类型X时，我们就可以说类型X兼容类型Y。
`X = Y` => `X 兼容 Y`

兼容可以理解为：
我兼容你，即我能包容你，我所必须的你都有，你多出的我不在乎。
相反你所必须的我满足不了，那我不兼容你。

技巧：
- 对象、接口、类和参数返回值，少的兼容多的
- 函数参数多的兼容少的


### 类型保护
TS能够在特定的区块中保证变量属于某种确定的类型
大概的意思是TS可以通过用户的辅助判断进行数据类型的断言，即判断该参数的类型。


### 交叉类型与联合类型
目的是为了保证语言的灵活性引入的语言特性。
**交叉类型**
取并集
将多个类型合并为一个类型，新类型将具有所有类型的特性。

**联合类型**
取交集
声明的类型并不确定，可以是多个类型中的一个
如果一个对象是联合类型，在类型未确定的情况下，只能访问所有类型的共有成员。

**可区分的联合类型**
一个类型如果是多个类型的联合类型，并且每个类型之间有一个共有的方法。


----
----

## 工程篇
### ES6与CommonJS模块系统
两者之间存在兼容问题。
ES Module支持`export default`导出与单独导出共存，而CommonJS顶级导出和单独导出只能二选一，所以ES Module会被编译为`exports.default`。全部使用ES Module不会出现问题。
当使用ES Module的default默认导出，使用CommonJS的默认导入时会出现问题。

### 命名空间
命名空间和模块不要混用，不要在模块中使用命名空间，最好在一个全局环境中使用。
本质上是一个闭包，现在使用的概率很小。

### 声明合并
多个地方（跨文件）定义的声明会被自动合并，最好不要使用。
因为一般不会使用命名空间，所以平时只需注意接口的命名合并即可。

### 如何编写声明文件
使用非TS编写的类库时，必须编写一个声明文件，暴露其API。

### 配置tsconfig.json 文件选项
### 配置tsconfig.json 编译选项
### 配置tsconfig.json 工具引用

### 从ts-loader到Babel
开启ts-loader的transpileOnly影响没法在编译时检查类型，关闭影响性能。
使用fork-ts-checker-webpack-plugin插件可以解决。
awesome-typescript-loader可以替代ts-loader，优点是更适合与Babel集成。
但还是建议使用ts-loader编译。

TSC与Babel的区别是Babel的插件丰富。Babel7以后支持TS

**Babel**
Babel有四种无法编译的TS语法。

总结：
首选TS的默认自身的编译器，ts-loader
如果项目中已经使用了Babel，则安装`@babel/preset-typescript`，可配合tsc做类型检查
两种编译方式不要混用

### 代码检查工具
官方开发重点以从TSLint迁移到ESLint。
TSLint的AST与ESLint语法输不兼容，使用typescript-eslint，将TS语法树转化为ESLint语法树

babel-eslint支持TS没有的额外语法检查，抛弃TS，不支持类型检查
typescript-eslint基于TS的AST，支持创建基于类型信息的规则。
两者不要一起使用，babel体系建议使用babel-eslint 否则使用typescript-eslint

- eslint
- @typescript-eslint/eslint-plugin
- @typescript-eslint/parser

- @types/jest
- @types/jquery
- @types/source-map
- awesome-typescript-loader
- fork-ts-checker-webpack-plugin
- jest
- ts-jest
- ts-loader
- typescript


----
----
jsx配置项目
- preserve: 生成的代码保留jsx，用于后续操作
- react-native
- react: js

- [ ] React预定义的类型 



babel-plugin-import: antd按需加载
customize-cra、react-app-rewired: 自定义react-create-app 
```
npm i antd axios react-router-dom
npm i -D babel-plugin-import customize-cra react-app-rewired http-server http-proxy-middleware
```

React.FC：
1、参数中隐含children
2、定义静态属性时提示

使用FC后，现在的默认属性必须设置可选，不建议使用FC。

数据请求的数据格式应该定义成接口

React.Types
- React.FC: react 函数组件
- React.ComponentType: react组件
- React.FormEvent: 表单事件（泛型接口）
- HTMLInputElement: input
- 

----
----
## 完成统计
❓: 从未看过
❗️: 重点
🔁: 需要再次观看

- 第一章：基础篇 (21讲)
	- 01. 重塑“类型思维”
	- 02. 类型基础（1）：强类型与弱类型
	- 03. 类型基础（2）：动态类型与静态类型
	- 04. 编写你的第一个TypeScript程序
	- 05. ❗️基本类型
	- 06. ❗️枚举类型
	- 07. ❗️接口（1）：对象类型接口
	- 08. ❗️接口（2）：函数类型接口
	- 09. ❗️函数相关知识点梳理
	- 10. ❗️类（1）：继承和成员修饰符
	- 11. ❗️类（2）：抽象类与多态
	- 12. ❗️类与接口的关系
	- 13. ❗️泛型（1）：泛型函数与泛型接口
	- 14. ❗️泛型（2）：泛型类与泛型约束
	- 15. ❗️类型检查机制（1）：类型推断
	- 16. ❗️类型检查机制（2）：类型兼容性
	- 17. ❗️类型检查机制（3）：类型保护
	- 18. ❗️高级类型（1）：交叉类型与联合类型
	- 19. ❗️高级类型（2）：索引类型
	- 20. ❗️高级类型（3）：映射类型
	- 21. ❗️高级类型（4）：条件类型
- 第二章：工程篇 (10讲)
	- 22. ❗️ES6与CommonJS的模块系统
	- 23. 使用命名空间
	- 24. ❗️理解声明合并
	- 25. 如何编写声明文件
	- 26. 🔁配置tsconfig.json（1）：文件选项
	- 27. 🔁配置tsconfig.json（2）：编译选项
	- 28. 🔁配置tsconfig.json（3）：工程引用
	- 29. 🔁编译工具：从ts-loader到Babel
	- 30. 🔁代码检查工具：从TSLint到ESLint
	- 31. 🔁使用Jest进行单元测试
- 第三章：实战篇 (16讲)
	- 32. 创建项目
	- 33. 组件与类型（1）：函数组件与类组件
	- 34. 组件与类型（2）：高阶组件与Hooks
	- 35. 事件处理与数据请求
	- 36. 列表渲染与路由
	- 37. ❓🔁Redux与类型
	- 38. ❓搭建服务端开发环境
	- 39. ❓列表的CRUD
	- 40. ❓导出Excel
	- 41. ❓搭建Vue开发环境
	- 42. ❓组件封装
	- 43. ❓组件发布
	- 44. ❓共存策略
	- 45. ❓宽松策略
	- 46. ❓严格策略
	- 47. 结课测试&结束语
